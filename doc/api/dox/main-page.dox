/**
@mainpage Welcome!

Welcome to the
<strong><em>Babeltrace \btversion C API</em></strong> documentation!

Since 2011, the open source <a
href="http://diamon.org/babeltrace">Babeltrace</a> project has grabbed a
leading position in the specific area of
<a href="https://en.wikipedia.org/wiki/Tracing_(software)">trace</a>
format conversion and CTF decoding. That being said, starting from
Babeltrace&nbsp;2, the tool and library can do much more than that.
Thanks to its plugin- and graph-oriented design, you can use the
Babeltrace&nbsp;2 library to selectively remove, augment, or transform
events, and to perform custom analyses with a trace format-agnostic
programming interface.

@note
This C API is completely wrapped by a thoroughly tested Python&nbsp;3
package. However, there is currently no available user documentation
for this package.


@section who Who is this documentation for?

This documentation is aimed at C/C++ programmers who need to do one or
more of the following tasks:

-# Write a Babeltrace plugin to provide a source of events, a custom
   way to filter or transform events, or to do something else with
   events, like write them to a file with a specific format.

-# Load existing Babeltrace plugins and connect what they provide in a
   specific way to achieve a goal.

-# An hybrid of #1 and #2.

@section intro Introduction

With the Babeltrace library, you can create conversion graphs. A
conversion graph contains connected components that pass on events and
other notifications from one to the other to accomplish some work. There
are three types of components:

- A \b source component produces trace events, usually getting them
  from one or more trace files.

- A \b filter component can manipulate the events it receives and move
  them to its output or produce new ones.

- A \b sink component consumes trace events. A sink component usually
  does something useful with the events, but not interesting for a
  following component, like write them to trace files.

Here's an example of a Babeltrace conversion graph built by the
\c babeltrace command-line tool:

@image html babeltrace-cli.png

It would be unfair not to compare the concept of a Babeltrace conversion
graph to other popular <a href="https://en.wikipedia.org/wiki/Filter_graph">filter
graphs</a> like the ones of
<a href="https://ffmpeg.org/">FFmpeg</a>,
<a href="https://gstreamer.freedesktop.org/">GStreamer</a>,
and
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd375454(v=vs.85).aspx">Microsoft DirectShow</a>.
Babeltrace and all those examples make use of filter graphs for the same
reason: reuse the graph nodes. Instead of hardcoding a specialized
MPEG-2 to H.263 video codec converter, developers create an MPEG-2
decoding node which produces raw video frames, an H.263 encoding node
which consumes raw video frames, and we connect them together. Then we
can plug this same MPEG-2 decoding node to a H.264 or VP9 encoding node.
This great modularity places a world of conversion possibilities at your
fingertips without having to write software at all.

But enough with the multimedia analogy. In the Babeltrace world, the
graph nodes, or \em components, do not send and receive video frames, but
\b notifications. One type of notification is the trace event
notification.

How do you make your own Babeltrace component? The C API has a few
functions that let you build your own <em>component class</em>. Here,
the term \em class has the same meaning as in object-oriented
programming: a component class is a set of user-defined methods. You can
use an API function to instantiate a component class as a component
instance, ready to be connected to other components within a conversion
graph.

While you can certainly create your own component classes, instantiate
them as components, and connect the components within a graph,
Babeltrace has a standard way to package them: \b plugins. A Babeltrace
plugin is a set of user-defined component classes. With the C API, you
can load existing plugins and create fresh ones. Concretly, you build a
plugin as a shared object.


The goal of using this API is to create user
\link btplugins <em>plugins</em>\endlink.


A Babeltrace plugin contains one or more
\link btcomponents <em>component classes</em>\endlink.

A component class is either:


A program or library can instantiate as many concrete \em components as
needed from a single component class. At component instantiation time,
the component class's registered user initialization function is called
with custom user parameters.

Plugins, as of Babeltrace \btversion, are built as dynamic libraries
(<code>.so</code> or <code>.dll</code> files) and loaded by the \c
babeltrace converter program. You can also get plugin objects from a
shared object file or from a directory containing shared object files
thanks to the C API. The converter program is responsible for passing
notifications and events from source components to filter components, if
any, and from filter components to sink components.

@image html babeltrace-cli.png

@section mainpagectfir CTF IR

The internal representations of a trace, a stream, and an event follow
the <a href="http://diamon.org/ctf">Common Trace Format</a> model.
Within the Babeltrace C API, this representation is called the
<em>Common Trace Format Intermediate Representation</em>, or
\link ctfir CTF IR\endlink. CTF IR is flexible enough to represent
almost any trace or logging format.

The CTF IR model contains the following objects, amongst others:

- A \link ctfirfieldtypes field type\endlink is the type of concrete
  \link ctfirfields fields\endlink.

  For example, an integer field type contains the size (in bits) of the
  integer fields it creates, as well as their byte order, whether or not
  they are signed, and so on. An integer field that you create out of an
  integer field type, however, only contains a raw integral value. You
  can create many fields from a single field type.

- An \link ctfireventclass event class\endlink is the type of
  a concrete \link ctfirevent event\endlink.

  An event class contains the field types of its various scopes, while
  an event contains the actual fields holding their values.

- A \link ctfirstreamclass stream class\endlink is the type of
  a concrete \link ctfirstream stream\endlink.

  A stream class contains the field types of its various scopes, while
  \link ctfirpacket packets\endlink attached to a
  \link ctfirstream stream\endlink instantiated from a
  stream class contains the actual
  fields holding their values. <p> A stream class is the parent of one or
  more event classes.


- A \link ctfirtraceclass trace class\endlink describes traces.

  A trace class is the parent of one or more stream classes.

- A \link ctfirclockclass clock class\endlink holds the common
  properties of clock values that are instantiated in \link ctfirevent
  events\endlink.

@section mainpagevalues Value objects

Some parts of the Babeltrace API require typical, generic scalar values
(boolean, integer, floating point number, string) organized in compound
objects (array, map). This is similar to the model that
<a href="http://json.org/">JSON</a> offers.

For example, the environment of a
\link ctfirtraceclass CTF IR trace class\endlink maps strings to strings
or to integers, and the parameters passed to component instances take
the form of a map.

For this purpose, the API uses
\link values value objects\endlink.

@section mainpageref Reference counting

All the <em>Babeltrace objects</em> have a
<a href="https://en.wikipedia.org/wiki/Reference_counting">reference count</a>
to make them shareable.
When you use a Babeltrace object creation function (for example,
bt_value_bool_create()), you get a new reference to the created
object. When you add this object to another one, the latter takes its
own reference using bt_get(), incrementing the shared object's reference
count. When you are done with an object, you must call bt_put() to drop
your reference, decrementing its reference count. When an object's
reference count reaches 0, the object is considered \em destroyed and
cannot be used anymore.

See \ref refs for more details.

The postconditions of the functions and macros documented here indicate
what you can expect from the reference counts of the Babeltrace objects
passed as parameters to and returned from API functions.

@section mainpagefreeze Frozen objects

The Babeltrace library can \em freeze almost all of the Babeltrace
objects. A frozen object is considered \em immutable, although you can
still get and put references to this object.

The preconditions of the functions and macros documented here indicate
when they expect unfrozen objects. The postconditions indicate when
the functions and macros freeze an object.
*/
